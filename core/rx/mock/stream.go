// Code generated by MockGen. DO NOT EDIT.
// Source: stream.go

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"
	time "time"

	backoff "github.com/cenkalti/backoff/v4"
	gomock "github.com/golang/mock/gomock"
	rxgo "github.com/reactivex/rxgo/v2"
	rx "github.com/yomorun/yomo/core/rx"
	decoder "github.com/yomorun/yomo/internal/decoder"
)

// MockStream is a mock of Stream interface.
type MockStream struct {
	ctrl     *gomock.Controller
	recorder *MockStreamMockRecorder
}

// MockStreamMockRecorder is the mock recorder for MockStream.
type MockStreamMockRecorder struct {
	mock *MockStream
}

// NewMockStream creates a new mock instance.
func NewMockStream(ctrl *gomock.Controller) *MockStream {
	mock := &MockStream{ctrl: ctrl}
	mock.recorder = &MockStreamMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStream) EXPECT() *MockStreamMockRecorder {
	return m.recorder
}

// All mocks base method.
func (m *MockStream) All(predicate rxgo.Predicate, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{predicate}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "All", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// All indicates an expected call of All.
func (mr *MockStreamMockRecorder) All(predicate interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{predicate}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "All", reflect.TypeOf((*MockStream)(nil).All), varargs...)
}

// AuditTime mocks base method.
func (m *MockStream) AuditTime(milliseconds uint32, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{milliseconds}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AuditTime", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// AuditTime indicates an expected call of AuditTime.
func (mr *MockStreamMockRecorder) AuditTime(milliseconds interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{milliseconds}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AuditTime", reflect.TypeOf((*MockStream)(nil).AuditTime), varargs...)
}

// AverageFloat32 mocks base method.
func (m *MockStream) AverageFloat32(opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AverageFloat32", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// AverageFloat32 indicates an expected call of AverageFloat32.
func (mr *MockStreamMockRecorder) AverageFloat32(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AverageFloat32", reflect.TypeOf((*MockStream)(nil).AverageFloat32), opts...)
}

// AverageFloat64 mocks base method.
func (m *MockStream) AverageFloat64(opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AverageFloat64", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// AverageFloat64 indicates an expected call of AverageFloat64.
func (mr *MockStreamMockRecorder) AverageFloat64(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AverageFloat64", reflect.TypeOf((*MockStream)(nil).AverageFloat64), opts...)
}

// AverageInt mocks base method.
func (m *MockStream) AverageInt(opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AverageInt", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// AverageInt indicates an expected call of AverageInt.
func (mr *MockStreamMockRecorder) AverageInt(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AverageInt", reflect.TypeOf((*MockStream)(nil).AverageInt), opts...)
}

// AverageInt16 mocks base method.
func (m *MockStream) AverageInt16(opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AverageInt16", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// AverageInt16 indicates an expected call of AverageInt16.
func (mr *MockStreamMockRecorder) AverageInt16(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AverageInt16", reflect.TypeOf((*MockStream)(nil).AverageInt16), opts...)
}

// AverageInt32 mocks base method.
func (m *MockStream) AverageInt32(opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AverageInt32", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// AverageInt32 indicates an expected call of AverageInt32.
func (mr *MockStreamMockRecorder) AverageInt32(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AverageInt32", reflect.TypeOf((*MockStream)(nil).AverageInt32), opts...)
}

// AverageInt64 mocks base method.
func (m *MockStream) AverageInt64(opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AverageInt64", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// AverageInt64 indicates an expected call of AverageInt64.
func (mr *MockStreamMockRecorder) AverageInt64(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AverageInt64", reflect.TypeOf((*MockStream)(nil).AverageInt64), opts...)
}

// AverageInt8 mocks base method.
func (m *MockStream) AverageInt8(opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AverageInt8", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// AverageInt8 indicates an expected call of AverageInt8.
func (mr *MockStreamMockRecorder) AverageInt8(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AverageInt8", reflect.TypeOf((*MockStream)(nil).AverageInt8), opts...)
}

// BackOffRetry mocks base method.
func (m *MockStream) BackOffRetry(backOffCfg backoff.BackOff, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{backOffCfg}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BackOffRetry", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// BackOffRetry indicates an expected call of BackOffRetry.
func (mr *MockStreamMockRecorder) BackOffRetry(backOffCfg interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{backOffCfg}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BackOffRetry", reflect.TypeOf((*MockStream)(nil).BackOffRetry), varargs...)
}

// BufferWithCount mocks base method.
func (m *MockStream) BufferWithCount(count int, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{count}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BufferWithCount", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// BufferWithCount indicates an expected call of BufferWithCount.
func (mr *MockStreamMockRecorder) BufferWithCount(count interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{count}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BufferWithCount", reflect.TypeOf((*MockStream)(nil).BufferWithCount), varargs...)
}

// BufferWithTime mocks base method.
func (m *MockStream) BufferWithTime(milliseconds uint32, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{milliseconds}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BufferWithTime", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// BufferWithTime indicates an expected call of BufferWithTime.
func (mr *MockStreamMockRecorder) BufferWithTime(milliseconds interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{milliseconds}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BufferWithTime", reflect.TypeOf((*MockStream)(nil).BufferWithTime), varargs...)
}

// BufferWithTimeOrCount mocks base method.
func (m *MockStream) BufferWithTimeOrCount(milliseconds uint32, count int, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{milliseconds, count}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BufferWithTimeOrCount", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// BufferWithTimeOrCount indicates an expected call of BufferWithTimeOrCount.
func (mr *MockStreamMockRecorder) BufferWithTimeOrCount(milliseconds, count interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{milliseconds, count}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BufferWithTimeOrCount", reflect.TypeOf((*MockStream)(nil).BufferWithTimeOrCount), varargs...)
}

// Connect mocks base method.
func (m *MockStream) Connect(ctx context.Context) (context.Context, rxgo.Disposable) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Connect", ctx)
	ret0, _ := ret[0].(context.Context)
	ret1, _ := ret[1].(rxgo.Disposable)
	return ret0, ret1
}

// Connect indicates an expected call of Connect.
func (mr *MockStreamMockRecorder) Connect(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Connect", reflect.TypeOf((*MockStream)(nil).Connect), ctx)
}

// Contains mocks base method.
func (m *MockStream) Contains(equal rxgo.Predicate, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{equal}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Contains", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Contains indicates an expected call of Contains.
func (mr *MockStreamMockRecorder) Contains(equal interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{equal}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Contains", reflect.TypeOf((*MockStream)(nil).Contains), varargs...)
}

// Count mocks base method.
func (m *MockStream) Count(opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Count", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Count indicates an expected call of Count.
func (mr *MockStreamMockRecorder) Count(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockStream)(nil).Count), opts...)
}

// Debounce mocks base method.
func (m *MockStream) Debounce(milliseconds uint32, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{milliseconds}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Debounce", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Debounce indicates an expected call of Debounce.
func (mr *MockStreamMockRecorder) Debounce(milliseconds interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{milliseconds}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Debounce", reflect.TypeOf((*MockStream)(nil).Debounce), varargs...)
}

// DefaultIfEmpty mocks base method.
func (m *MockStream) DefaultIfEmpty(defaultValue interface{}, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{defaultValue}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DefaultIfEmpty", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// DefaultIfEmpty indicates an expected call of DefaultIfEmpty.
func (mr *MockStreamMockRecorder) DefaultIfEmpty(defaultValue interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{defaultValue}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DefaultIfEmpty", reflect.TypeOf((*MockStream)(nil).DefaultIfEmpty), varargs...)
}

// DefaultIfEmptyWithTime mocks base method.
func (m *MockStream) DefaultIfEmptyWithTime(milliseconds uint32, defaultValue interface{}, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{milliseconds, defaultValue}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DefaultIfEmptyWithTime", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// DefaultIfEmptyWithTime indicates an expected call of DefaultIfEmptyWithTime.
func (mr *MockStreamMockRecorder) DefaultIfEmptyWithTime(milliseconds, defaultValue interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{milliseconds, defaultValue}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DefaultIfEmptyWithTime", reflect.TypeOf((*MockStream)(nil).DefaultIfEmptyWithTime), varargs...)
}

// Distinct mocks base method.
func (m *MockStream) Distinct(apply rxgo.Func, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{apply}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Distinct", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Distinct indicates an expected call of Distinct.
func (mr *MockStreamMockRecorder) Distinct(apply interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{apply}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Distinct", reflect.TypeOf((*MockStream)(nil).Distinct), varargs...)
}

// DistinctUntilChanged mocks base method.
func (m *MockStream) DistinctUntilChanged(apply rxgo.Func, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{apply}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DistinctUntilChanged", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// DistinctUntilChanged indicates an expected call of DistinctUntilChanged.
func (mr *MockStreamMockRecorder) DistinctUntilChanged(apply interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{apply}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DistinctUntilChanged", reflect.TypeOf((*MockStream)(nil).DistinctUntilChanged), varargs...)
}

// DoOnCompleted mocks base method.
func (m *MockStream) DoOnCompleted(completedFunc rxgo.CompletedFunc, opts ...rxgo.Option) rxgo.Disposed {
	m.ctrl.T.Helper()
	varargs := []interface{}{completedFunc}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DoOnCompleted", varargs...)
	ret0, _ := ret[0].(rxgo.Disposed)
	return ret0
}

// DoOnCompleted indicates an expected call of DoOnCompleted.
func (mr *MockStreamMockRecorder) DoOnCompleted(completedFunc interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{completedFunc}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoOnCompleted", reflect.TypeOf((*MockStream)(nil).DoOnCompleted), varargs...)
}

// DoOnError mocks base method.
func (m *MockStream) DoOnError(errFunc rxgo.ErrFunc, opts ...rxgo.Option) rxgo.Disposed {
	m.ctrl.T.Helper()
	varargs := []interface{}{errFunc}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DoOnError", varargs...)
	ret0, _ := ret[0].(rxgo.Disposed)
	return ret0
}

// DoOnError indicates an expected call of DoOnError.
func (mr *MockStreamMockRecorder) DoOnError(errFunc interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{errFunc}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoOnError", reflect.TypeOf((*MockStream)(nil).DoOnError), varargs...)
}

// DoOnNext mocks base method.
func (m *MockStream) DoOnNext(nextFunc rxgo.NextFunc, opts ...rxgo.Option) rxgo.Disposed {
	m.ctrl.T.Helper()
	varargs := []interface{}{nextFunc}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DoOnNext", varargs...)
	ret0, _ := ret[0].(rxgo.Disposed)
	return ret0
}

// DoOnNext indicates an expected call of DoOnNext.
func (mr *MockStreamMockRecorder) DoOnNext(nextFunc interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{nextFunc}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoOnNext", reflect.TypeOf((*MockStream)(nil).DoOnNext), varargs...)
}

// ElementAt mocks base method.
func (m *MockStream) ElementAt(index uint, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{index}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ElementAt", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// ElementAt indicates an expected call of ElementAt.
func (mr *MockStreamMockRecorder) ElementAt(index interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{index}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ElementAt", reflect.TypeOf((*MockStream)(nil).ElementAt), varargs...)
}

// Encode mocks base method.
func (m *MockStream) Encode(key byte, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{key}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Encode", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Encode indicates an expected call of Encode.
func (mr *MockStreamMockRecorder) Encode(key interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{key}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Encode", reflect.TypeOf((*MockStream)(nil).Encode), varargs...)
}

// Error mocks base method.
func (m *MockStream) Error(opts ...rxgo.Option) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Error", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Error indicates an expected call of Error.
func (mr *MockStreamMockRecorder) Error(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockStream)(nil).Error), opts...)
}

// Errors mocks base method.
func (m *MockStream) Errors(opts ...rxgo.Option) []error {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Errors", varargs...)
	ret0, _ := ret[0].([]error)
	return ret0
}

// Errors indicates an expected call of Errors.
func (mr *MockStreamMockRecorder) Errors(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Errors", reflect.TypeOf((*MockStream)(nil).Errors), opts...)
}

// Filter mocks base method.
func (m *MockStream) Filter(apply rxgo.Predicate, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{apply}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Filter", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Filter indicates an expected call of Filter.
func (mr *MockStreamMockRecorder) Filter(apply interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{apply}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Filter", reflect.TypeOf((*MockStream)(nil).Filter), varargs...)
}

// Find mocks base method.
func (m *MockStream) Find(find rxgo.Predicate, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{find}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Find", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Find indicates an expected call of Find.
func (mr *MockStreamMockRecorder) Find(find interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{find}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Find", reflect.TypeOf((*MockStream)(nil).Find), varargs...)
}

// First mocks base method.
func (m *MockStream) First(opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "First", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// First indicates an expected call of First.
func (mr *MockStreamMockRecorder) First(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "First", reflect.TypeOf((*MockStream)(nil).First), opts...)
}

// FirstOrDefault mocks base method.
func (m *MockStream) FirstOrDefault(defaultValue interface{}, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{defaultValue}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FirstOrDefault", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// FirstOrDefault indicates an expected call of FirstOrDefault.
func (mr *MockStreamMockRecorder) FirstOrDefault(defaultValue interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{defaultValue}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FirstOrDefault", reflect.TypeOf((*MockStream)(nil).FirstOrDefault), varargs...)
}

// FlatMap mocks base method.
func (m *MockStream) FlatMap(apply rxgo.ItemToObservable, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{apply}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FlatMap", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// FlatMap indicates an expected call of FlatMap.
func (mr *MockStreamMockRecorder) FlatMap(apply interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{apply}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FlatMap", reflect.TypeOf((*MockStream)(nil).FlatMap), varargs...)
}

// ForEach mocks base method.
func (m *MockStream) ForEach(nextFunc rxgo.NextFunc, errFunc rxgo.ErrFunc, completedFunc rxgo.CompletedFunc, opts ...rxgo.Option) rxgo.Disposed {
	m.ctrl.T.Helper()
	varargs := []interface{}{nextFunc, errFunc, completedFunc}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ForEach", varargs...)
	ret0, _ := ret[0].(rxgo.Disposed)
	return ret0
}

// ForEach indicates an expected call of ForEach.
func (mr *MockStreamMockRecorder) ForEach(nextFunc, errFunc, completedFunc interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{nextFunc, errFunc, completedFunc}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ForEach", reflect.TypeOf((*MockStream)(nil).ForEach), varargs...)
}

// GroupBy mocks base method.
func (m *MockStream) GroupBy(length int, distribution func(rxgo.Item) int, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{length, distribution}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GroupBy", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// GroupBy indicates an expected call of GroupBy.
func (mr *MockStreamMockRecorder) GroupBy(length, distribution interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{length, distribution}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GroupBy", reflect.TypeOf((*MockStream)(nil).GroupBy), varargs...)
}

// GroupByDynamic mocks base method.
func (m *MockStream) GroupByDynamic(distribution func(rxgo.Item) string, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{distribution}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GroupByDynamic", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// GroupByDynamic indicates an expected call of GroupByDynamic.
func (mr *MockStreamMockRecorder) GroupByDynamic(distribution interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{distribution}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GroupByDynamic", reflect.TypeOf((*MockStream)(nil).GroupByDynamic), varargs...)
}

// IgnoreElements mocks base method.
func (m *MockStream) IgnoreElements(opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "IgnoreElements", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// IgnoreElements indicates an expected call of IgnoreElements.
func (mr *MockStreamMockRecorder) IgnoreElements(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IgnoreElements", reflect.TypeOf((*MockStream)(nil).IgnoreElements), opts...)
}

// Join mocks base method.
func (m *MockStream) Join(joiner rxgo.Func2, right rxgo.Observable, timeExtractor func(interface{}) time.Time, windowInMS uint32, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{joiner, right, timeExtractor, windowInMS}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Join", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Join indicates an expected call of Join.
func (mr *MockStreamMockRecorder) Join(joiner, right, timeExtractor, windowInMS interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{joiner, right, timeExtractor, windowInMS}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Join", reflect.TypeOf((*MockStream)(nil).Join), varargs...)
}

// Last mocks base method.
func (m *MockStream) Last(opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Last", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Last indicates an expected call of Last.
func (mr *MockStreamMockRecorder) Last(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Last", reflect.TypeOf((*MockStream)(nil).Last), opts...)
}

// LastOrDefault mocks base method.
func (m *MockStream) LastOrDefault(defaultValue interface{}, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{defaultValue}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LastOrDefault", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// LastOrDefault indicates an expected call of LastOrDefault.
func (mr *MockStreamMockRecorder) LastOrDefault(defaultValue interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{defaultValue}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastOrDefault", reflect.TypeOf((*MockStream)(nil).LastOrDefault), varargs...)
}

// Map mocks base method.
func (m *MockStream) Map(apply rxgo.Func, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{apply}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Map", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Map indicates an expected call of Map.
func (mr *MockStreamMockRecorder) Map(apply interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{apply}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Map", reflect.TypeOf((*MockStream)(nil).Map), varargs...)
}

// Marshal mocks base method.
func (m *MockStream) Marshal(marshaller decoder.Marshaller, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{marshaller}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Marshal", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Marshal indicates an expected call of Marshal.
func (mr *MockStreamMockRecorder) Marshal(marshaller interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{marshaller}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Marshal", reflect.TypeOf((*MockStream)(nil).Marshal), varargs...)
}

// Max mocks base method.
func (m *MockStream) Max(comparator rxgo.Comparator, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{comparator}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Max", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Max indicates an expected call of Max.
func (mr *MockStreamMockRecorder) Max(comparator interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{comparator}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Max", reflect.TypeOf((*MockStream)(nil).Max), varargs...)
}

// Min mocks base method.
func (m *MockStream) Min(comparator rxgo.Comparator, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{comparator}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Min", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Min indicates an expected call of Min.
func (mr *MockStreamMockRecorder) Min(comparator interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{comparator}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Min", reflect.TypeOf((*MockStream)(nil).Min), varargs...)
}

// Observe mocks base method.
func (m *MockStream) Observe(opts ...rxgo.Option) <-chan rxgo.Item {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Observe", varargs...)
	ret0, _ := ret[0].(<-chan rxgo.Item)
	return ret0
}

// Observe indicates an expected call of Observe.
func (mr *MockStreamMockRecorder) Observe(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Observe", reflect.TypeOf((*MockStream)(nil).Observe), opts...)
}

// OnErrorResumeNext mocks base method.
func (m *MockStream) OnErrorResumeNext(resumeSequence rxgo.ErrorToObservable, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{resumeSequence}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "OnErrorResumeNext", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// OnErrorResumeNext indicates an expected call of OnErrorResumeNext.
func (mr *MockStreamMockRecorder) OnErrorResumeNext(resumeSequence interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{resumeSequence}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnErrorResumeNext", reflect.TypeOf((*MockStream)(nil).OnErrorResumeNext), varargs...)
}

// OnErrorReturn mocks base method.
func (m *MockStream) OnErrorReturn(resumeFunc rxgo.ErrorFunc, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{resumeFunc}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "OnErrorReturn", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// OnErrorReturn indicates an expected call of OnErrorReturn.
func (mr *MockStreamMockRecorder) OnErrorReturn(resumeFunc interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{resumeFunc}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnErrorReturn", reflect.TypeOf((*MockStream)(nil).OnErrorReturn), varargs...)
}

// OnErrorReturnItem mocks base method.
func (m *MockStream) OnErrorReturnItem(resume interface{}, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{resume}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "OnErrorReturnItem", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// OnErrorReturnItem indicates an expected call of OnErrorReturnItem.
func (mr *MockStreamMockRecorder) OnErrorReturnItem(resume interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{resume}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnErrorReturnItem", reflect.TypeOf((*MockStream)(nil).OnErrorReturnItem), varargs...)
}

// OnObserve mocks base method.
func (m *MockStream) OnObserve(function func([]byte) (interface{}, error)) rx.Stream {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnObserve", function)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// OnObserve indicates an expected call of OnObserve.
func (mr *MockStreamMockRecorder) OnObserve(function interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnObserve", reflect.TypeOf((*MockStream)(nil).OnObserve), function)
}

// RawBytes mocks base method.
func (m *MockStream) RawBytes() rx.Stream {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RawBytes")
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// RawBytes indicates an expected call of RawBytes.
func (mr *MockStreamMockRecorder) RawBytes() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RawBytes", reflect.TypeOf((*MockStream)(nil).RawBytes))
}

// Reduce mocks base method.
func (m *MockStream) Reduce(apply rxgo.Func2, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{apply}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Reduce", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Reduce indicates an expected call of Reduce.
func (mr *MockStreamMockRecorder) Reduce(apply interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{apply}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Reduce", reflect.TypeOf((*MockStream)(nil).Reduce), varargs...)
}

// Repeat mocks base method.
func (m *MockStream) Repeat(count int64, milliseconds uint32, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{count, milliseconds}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Repeat", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Repeat indicates an expected call of Repeat.
func (mr *MockStreamMockRecorder) Repeat(count, milliseconds interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{count, milliseconds}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Repeat", reflect.TypeOf((*MockStream)(nil).Repeat), varargs...)
}

// Retry mocks base method.
func (m *MockStream) Retry(count int, shouldRetry func(error) bool, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{count, shouldRetry}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Retry", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Retry indicates an expected call of Retry.
func (mr *MockStreamMockRecorder) Retry(count, shouldRetry interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{count, shouldRetry}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Retry", reflect.TypeOf((*MockStream)(nil).Retry), varargs...)
}

// Run mocks base method.
func (m *MockStream) Run(opts ...rxgo.Option) rxgo.Disposed {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Run", varargs...)
	ret0, _ := ret[0].(rxgo.Disposed)
	return ret0
}

// Run indicates an expected call of Run.
func (mr *MockStreamMockRecorder) Run(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockStream)(nil).Run), opts...)
}

// Sample mocks base method.
func (m *MockStream) Sample(iterable rxgo.Iterable, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{iterable}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Sample", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Sample indicates an expected call of Sample.
func (mr *MockStreamMockRecorder) Sample(iterable interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{iterable}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sample", reflect.TypeOf((*MockStream)(nil).Sample), varargs...)
}

// Scan mocks base method.
func (m *MockStream) Scan(apply rxgo.Func2, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{apply}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Scan", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Scan indicates an expected call of Scan.
func (mr *MockStreamMockRecorder) Scan(apply interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{apply}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*MockStream)(nil).Scan), varargs...)
}

// Send mocks base method.
func (m *MockStream) Send(output chan<- rxgo.Item, opts ...rxgo.Option) {
	m.ctrl.T.Helper()
	varargs := []interface{}{output}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Send", varargs...)
}

// Send indicates an expected call of Send.
func (mr *MockStreamMockRecorder) Send(output interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{output}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Send", reflect.TypeOf((*MockStream)(nil).Send), varargs...)
}

// SequenceEqual mocks base method.
func (m *MockStream) SequenceEqual(iterable rxgo.Iterable, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{iterable}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SequenceEqual", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// SequenceEqual indicates an expected call of SequenceEqual.
func (mr *MockStreamMockRecorder) SequenceEqual(iterable interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{iterable}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SequenceEqual", reflect.TypeOf((*MockStream)(nil).SequenceEqual), varargs...)
}

// Serialize mocks base method.
func (m *MockStream) Serialize(from int, identifier func(interface{}) int, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{from, identifier}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Serialize", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Serialize indicates an expected call of Serialize.
func (mr *MockStreamMockRecorder) Serialize(from, identifier interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{from, identifier}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Serialize", reflect.TypeOf((*MockStream)(nil).Serialize), varargs...)
}

// Skip mocks base method.
func (m *MockStream) Skip(nth uint, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{nth}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Skip", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Skip indicates an expected call of Skip.
func (mr *MockStreamMockRecorder) Skip(nth interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{nth}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Skip", reflect.TypeOf((*MockStream)(nil).Skip), varargs...)
}

// SkipLast mocks base method.
func (m *MockStream) SkipLast(nth uint, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{nth}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SkipLast", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// SkipLast indicates an expected call of SkipLast.
func (mr *MockStreamMockRecorder) SkipLast(nth interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{nth}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SkipLast", reflect.TypeOf((*MockStream)(nil).SkipLast), varargs...)
}

// SkipWhile mocks base method.
func (m *MockStream) SkipWhile(apply rxgo.Predicate, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{apply}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SkipWhile", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// SkipWhile indicates an expected call of SkipWhile.
func (mr *MockStreamMockRecorder) SkipWhile(apply interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{apply}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SkipWhile", reflect.TypeOf((*MockStream)(nil).SkipWhile), varargs...)
}

// SlidingWindowWithCount mocks base method.
func (m *MockStream) SlidingWindowWithCount(windowSize, slideSize int, handler rx.Handler, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{windowSize, slideSize, handler}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SlidingWindowWithCount", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// SlidingWindowWithCount indicates an expected call of SlidingWindowWithCount.
func (mr *MockStreamMockRecorder) SlidingWindowWithCount(windowSize, slideSize, handler interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{windowSize, slideSize, handler}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SlidingWindowWithCount", reflect.TypeOf((*MockStream)(nil).SlidingWindowWithCount), varargs...)
}

// SlidingWindowWithTime mocks base method.
func (m *MockStream) SlidingWindowWithTime(windowTimeInMS, slideTimeInMS uint32, handler rx.Handler, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{windowTimeInMS, slideTimeInMS, handler}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SlidingWindowWithTime", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// SlidingWindowWithTime indicates an expected call of SlidingWindowWithTime.
func (mr *MockStreamMockRecorder) SlidingWindowWithTime(windowTimeInMS, slideTimeInMS, handler interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{windowTimeInMS, slideTimeInMS, handler}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SlidingWindowWithTime", reflect.TypeOf((*MockStream)(nil).SlidingWindowWithTime), varargs...)
}

// StartWith mocks base method.
func (m *MockStream) StartWith(iterable rxgo.Iterable, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{iterable}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "StartWith", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// StartWith indicates an expected call of StartWith.
func (mr *MockStreamMockRecorder) StartWith(iterable interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{iterable}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartWith", reflect.TypeOf((*MockStream)(nil).StartWith), varargs...)
}

// StdOut mocks base method.
func (m *MockStream) StdOut(opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "StdOut", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// StdOut indicates an expected call of StdOut.
func (mr *MockStreamMockRecorder) StdOut(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StdOut", reflect.TypeOf((*MockStream)(nil).StdOut), opts...)
}

// Subscribe mocks base method.
func (m *MockStream) Subscribe(key byte) rx.Stream {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Subscribe", key)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockStreamMockRecorder) Subscribe(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockStream)(nil).Subscribe), key)
}

// SumFloat32 mocks base method.
func (m *MockStream) SumFloat32(opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SumFloat32", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// SumFloat32 indicates an expected call of SumFloat32.
func (mr *MockStreamMockRecorder) SumFloat32(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SumFloat32", reflect.TypeOf((*MockStream)(nil).SumFloat32), opts...)
}

// SumFloat64 mocks base method.
func (m *MockStream) SumFloat64(opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SumFloat64", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// SumFloat64 indicates an expected call of SumFloat64.
func (mr *MockStreamMockRecorder) SumFloat64(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SumFloat64", reflect.TypeOf((*MockStream)(nil).SumFloat64), opts...)
}

// SumInt64 mocks base method.
func (m *MockStream) SumInt64(opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SumInt64", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// SumInt64 indicates an expected call of SumInt64.
func (mr *MockStreamMockRecorder) SumInt64(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SumInt64", reflect.TypeOf((*MockStream)(nil).SumInt64), opts...)
}

// Take mocks base method.
func (m *MockStream) Take(nth uint, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{nth}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Take", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Take indicates an expected call of Take.
func (mr *MockStreamMockRecorder) Take(nth interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{nth}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Take", reflect.TypeOf((*MockStream)(nil).Take), varargs...)
}

// TakeLast mocks base method.
func (m *MockStream) TakeLast(nth uint, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{nth}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TakeLast", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// TakeLast indicates an expected call of TakeLast.
func (mr *MockStreamMockRecorder) TakeLast(nth interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{nth}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TakeLast", reflect.TypeOf((*MockStream)(nil).TakeLast), varargs...)
}

// TakeUntil mocks base method.
func (m *MockStream) TakeUntil(apply rxgo.Predicate, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{apply}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TakeUntil", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// TakeUntil indicates an expected call of TakeUntil.
func (mr *MockStreamMockRecorder) TakeUntil(apply interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{apply}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TakeUntil", reflect.TypeOf((*MockStream)(nil).TakeUntil), varargs...)
}

// TakeWhile mocks base method.
func (m *MockStream) TakeWhile(apply rxgo.Predicate, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{apply}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TakeWhile", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// TakeWhile indicates an expected call of TakeWhile.
func (mr *MockStreamMockRecorder) TakeWhile(apply interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{apply}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TakeWhile", reflect.TypeOf((*MockStream)(nil).TakeWhile), varargs...)
}

// TimeInterval mocks base method.
func (m *MockStream) TimeInterval(opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TimeInterval", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// TimeInterval indicates an expected call of TimeInterval.
func (mr *MockStreamMockRecorder) TimeInterval(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TimeInterval", reflect.TypeOf((*MockStream)(nil).TimeInterval), opts...)
}

// Timestamp mocks base method.
func (m *MockStream) Timestamp(opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Timestamp", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Timestamp indicates an expected call of Timestamp.
func (mr *MockStreamMockRecorder) Timestamp(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Timestamp", reflect.TypeOf((*MockStream)(nil).Timestamp), opts...)
}

// ToMap mocks base method.
func (m *MockStream) ToMap(keySelector rxgo.Func, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{keySelector}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ToMap", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// ToMap indicates an expected call of ToMap.
func (mr *MockStreamMockRecorder) ToMap(keySelector interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{keySelector}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ToMap", reflect.TypeOf((*MockStream)(nil).ToMap), varargs...)
}

// ToMapWithValueSelector mocks base method.
func (m *MockStream) ToMapWithValueSelector(keySelector, valueSelector rxgo.Func, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{keySelector, valueSelector}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ToMapWithValueSelector", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// ToMapWithValueSelector indicates an expected call of ToMapWithValueSelector.
func (mr *MockStreamMockRecorder) ToMapWithValueSelector(keySelector, valueSelector interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{keySelector, valueSelector}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ToMapWithValueSelector", reflect.TypeOf((*MockStream)(nil).ToMapWithValueSelector), varargs...)
}

// ToSlice mocks base method.
func (m *MockStream) ToSlice(initialCapacity int, opts ...rxgo.Option) ([]interface{}, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{initialCapacity}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ToSlice", varargs...)
	ret0, _ := ret[0].([]interface{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ToSlice indicates an expected call of ToSlice.
func (mr *MockStreamMockRecorder) ToSlice(initialCapacity interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{initialCapacity}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ToSlice", reflect.TypeOf((*MockStream)(nil).ToSlice), varargs...)
}

// Unmarshal mocks base method.
func (m *MockStream) Unmarshal(unmarshaller decoder.Unmarshaller, factory func() interface{}, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{unmarshaller, factory}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Unmarshal", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// Unmarshal indicates an expected call of Unmarshal.
func (mr *MockStreamMockRecorder) Unmarshal(unmarshaller, factory interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{unmarshaller, factory}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unmarshal", reflect.TypeOf((*MockStream)(nil).Unmarshal), varargs...)
}

// WindowWithCount mocks base method.
func (m *MockStream) WindowWithCount(count int, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{count}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WindowWithCount", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// WindowWithCount indicates an expected call of WindowWithCount.
func (mr *MockStreamMockRecorder) WindowWithCount(count interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{count}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WindowWithCount", reflect.TypeOf((*MockStream)(nil).WindowWithCount), varargs...)
}

// WindowWithTime mocks base method.
func (m *MockStream) WindowWithTime(milliseconds uint32, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{milliseconds}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WindowWithTime", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// WindowWithTime indicates an expected call of WindowWithTime.
func (mr *MockStreamMockRecorder) WindowWithTime(milliseconds interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{milliseconds}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WindowWithTime", reflect.TypeOf((*MockStream)(nil).WindowWithTime), varargs...)
}

// WindowWithTimeOrCount mocks base method.
func (m *MockStream) WindowWithTimeOrCount(milliseconds uint32, count int, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{milliseconds, count}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WindowWithTimeOrCount", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// WindowWithTimeOrCount indicates an expected call of WindowWithTimeOrCount.
func (mr *MockStreamMockRecorder) WindowWithTimeOrCount(milliseconds, count interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{milliseconds, count}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WindowWithTimeOrCount", reflect.TypeOf((*MockStream)(nil).WindowWithTimeOrCount), varargs...)
}

// ZipFromIterable mocks base method.
func (m *MockStream) ZipFromIterable(iterable rxgo.Iterable, zipper rxgo.Func2, opts ...rxgo.Option) rx.Stream {
	m.ctrl.T.Helper()
	varargs := []interface{}{iterable, zipper}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ZipFromIterable", varargs...)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// ZipFromIterable indicates an expected call of ZipFromIterable.
func (mr *MockStreamMockRecorder) ZipFromIterable(iterable, zipper interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{iterable, zipper}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZipFromIterable", reflect.TypeOf((*MockStream)(nil).ZipFromIterable), varargs...)
}

// ZipMultiObservers mocks base method.
func (m *MockStream) ZipMultiObservers(observers []rx.KeyObserveFunc, zipper func([]interface{}) (interface{}, error)) rx.Stream {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZipMultiObservers", observers, zipper)
	ret0, _ := ret[0].(rx.Stream)
	return ret0
}

// ZipMultiObservers indicates an expected call of ZipMultiObservers.
func (mr *MockStreamMockRecorder) ZipMultiObservers(observers, zipper interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZipMultiObservers", reflect.TypeOf((*MockStream)(nil).ZipMultiObservers), observers, zipper)
}
